use std::pin::Pin;
use std::task::{Context, Poll};

#[cfg(doc)]
use crate::client::Client;
use crate::client::MakeFuture;
use crate::client::utils::LazyMakeFuture;
use crate::protocol::v5;

pin_project_lite::pin_project! {
    /// Future returned by [`Client::connect`].
    ///
    /// # Cancel safety
    ///
    /// This future is *not* cancel safe.
    #[must_use = "futures do nothing unless you `.await` or poll them"]
    pub struct Connect<'a, T> {
        packet: v5::Connect<'a>,
        #[pin]
        inner: T,
    }
}

impl<'a, T> Connect<'a, T> {
    /// Configures the keep a live interval.
    ///
    /// Clients must periodically send a keep-alive message with this interval to inform the server
    /// about its presence.
    ///
    /// Note: The client currently does not implement automatic keep alive messages and these must
    /// be generated by the user.
    pub fn keep_alive(mut self, keep_alive: u16) -> Self {
        self.packet.keep_alive = keep_alive;
        self
    }

    /// Whether the server should attempt to resume an already existing session.
    ///
    /// Defaults to `false`.
    ///
    /// Note: While session resumption is configurable, at this time the client does not implement
    /// session resumption. This may lead to hanging connection or lost messages while the client
    /// was not connected.
    pub fn resume_session(mut self, resume: bool) -> Self {
        self.packet.clean_start = !resume;
        self
    }

    /// Configures the username for authentication with the broker.
    pub fn with_username<S>(mut self, username: S) -> Self
    where
        S: Into<Option<&'a str>>,
    {
        self.packet.username = username.into();
        self
    }

    /// Configures the password for authentication with the broker.
    pub fn with_password<S>(mut self, password: S) -> Self
    where
        S: Into<Option<&'a str>>,
    {
        self.packet.password = password.into();
        self
    }

    /// Configures additional properties for the connection.
    pub fn with_properties(mut self, properties: &'a [v5::ConnectProperty<'a>]) -> Self {
        self.packet.properties = properties;
        self
    }
}

impl Connect<'_, ()> {
    pub(super) fn new<'a, M, F, O>(
        client_id: &'a str,
        m: M,
    ) -> Connect<'a, impl MakeFuture<v5::Connect<'a>, Output = O>>
    where
        M: FnOnce(v5::Connect<'a>) -> F,
        F: Future<Output = O>,
    {
        let packet = v5::Connect {
            client_id,
            keep_alive: 0,
            clean_start: true,
            will: None,
            username: None,
            password: None,
            properties: &[],
        };

        Connect {
            packet,
            inner: LazyMakeFuture::new(m),
        }
    }
}

impl<'a, M> Future for Connect<'a, M>
where
    M: MakeFuture<v5::Connect<'a>>,
{
    type Output = M::Output;

    fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {
        let this = self.project();
        this.inner.poll(&*this.packet, cx)
    }
}

/// The response from the server to a [`Connect`] request.
#[derive(Debug)]
pub struct ConnectResponse {
    pub(super) ack: v5::ConnAck,
}

// TODO: this is all a bit lack-luster, the reason isn't exposed, properties aren't exposed,
// error handling sucks, because clients need to explicitly check for success.
//
// There should probably a good way to turn this into some kind of Result<> where clients can
// just `?` the response.
impl ConnectResponse {
    /// Returns whether the connection was successful.
    ///
    /// After an unsuccessful connect attempt, the connection must be closed.
    pub fn successful(&self) -> bool {
        self.ack.reason == v5::ConnAckReason::Success
    }

    /// Whether the server resumed an existing client session.
    pub fn session_present(&self) -> bool {
        self.ack.ack_flags & 1 == 1
    }
}
